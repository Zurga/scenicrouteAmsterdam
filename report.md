# Final report

## App description
Most people who cycle in Amsterdam have their own ingrained routes they use to get from point A to point B. But the city has a lot of sights to offer which are missed. This app tries to provide an alternative to the shortest route by incorporating as many sights as possible based on the shortest route. The route provided will be a little longer, but will hopefully provide a nicer experience to the traveller. The traveller will take the scenic route.

A scenic route will be defined as a route with a maximum of 6 POI's on the way and a length not larger than 20% of the length of the shortest route.
Points of interest are:
- bridges,
- points near waterways,
- museums,
- squares,
- monumental buildings,
- parks.

Because people have places they commute to more often, an quick and easy interface is necessary to make the usage of the app as pleasant as possible before they set of on their commute. The interface incorporates that by being as easy to use as possible.

![](screenshot.png)
## Functionality
The codebase has been separated in different aspects of the application. These aspects are:

- Activities; holds all the code necessary to have the user interact with the application and display the screens necessary to interact. The activities are: MainActivity, MapsActivity and MyRoutesActivity.
- Adapters; responsible for gathering the data from the database and display it in a list. They also implement the functions used to interact with the items on the list.
- Async; responsible for the interaction with the server.
- Classes; hass a constants class.
- Interfaces; all the interfaces used in activities.
- Models; holds the classes that describe a Route, Point, LatLong and point of interest.
- Libraries used: Parcels, to easily pass model objects to other activities; ShowCaseView to display a tutorial; DavidWebb, used to easily do requests to the server.

The basic flow the appliction looks like this.

MainActivity --> MapsActivity --> MainActivity --> MyRoutesActivity

### Activities
To abstract away most of the boilerplate code involved with connecting to the database, Firebase authentication and other such stuff, a BaseActivity class has been created. This class holds the following methods which can be used by the MainActivity and the MyRoutesActivity:

- displaying progressDialogs;
- setting up the external apis such as Firebase;
- creating and setting the onClickListeners for the authentication dialogs.
- logging in, creating an account and signing in anonymously.
- keeping track of selected items in the adapters.
- setting up the menu and displaying or hiding certain menu items based on the application state.
- displaying a showcase if the app has been started the first time.
- implements the interface to start the MapsActivity when a route has been created.

#### MainActivity (BaseActivity)
The MainActivity is the first screen that the user will see. In this activity they can enter the start- and endpoint of their journey. It also includes a list of most used address pairs sorted by the frequency of use. The start and end location of the journey is obtained with the help of the AutoCompleteFragment provided by the Google Places library. These fragments have been optimized to show Dutch geographic places first. The MainActivity also sets the RouteAdapter on the most used routes listview to display the most used address pairs. If all the necessary information has been entered, a route is generated using the RouteGetter. When this finishes asynchronously the interface OnRouteReceived will ensure the MapsActivity is started.

#### MyRoutesActivity (BaseActivity)
The MyRouteActivity will display all the routes saved by the user. These routes contain the points that where generated by the server. It also uses the RouteAdapter to display this list of routes.

#### MapsActivity
The MapsActivity will first connect to the GoogleApiClient, this enables it to use the location of the user. When this is done it will draw the route on the map and create markers for the points of interest. The points of interest can be clicked to display an information window. If that information window is then tapped, the InformationActivity will start to display the information about the point of interest. The times an address pair has been used is updated in the database when the activity is started.

#### InformationActivity
The information about a POI is displayed in this activity which is passed by the MapsActivity. If the POI has the "uri" field set, the webpage for of the uri will be loaded inside the WebView, else the activity will call the "generateHTML" on the POI and display that in its WebView.

### Adapters
#### RouteAdapter
The RouteAdapter is used to display a Route class from the database. It is an extension of the ArrayAdapter provided by Android. It has the code necessary to sync with the Firebase database and perform CRUD operations on this database and in the app. By using interfaces which are implemented in the BaseActivity, the adapter is reusable in multiple activities.

### Async
#### RouteGetter
The RouteGetter is an extension of the AsyncTask provided by Android. This class create a Route object which it passes to the listening Activity when the interaction with the server is done. It can create a Route from an address pair from Firebase or with the information from the MainActivity. To make the code that creates the request to the server more readable, the DavidWebb library is used which abstracts a lot of the basic Java HTTP code away from the main codebase.

### Classes
#### Constants
This class holds all the constants used throughout the application.

### Interfaces
#### RouteItemSelected
Passes the key of the route item selected in the adapter to the listening activity which will then add to its own list selected items.

#### RouteReceived
Passes the route object from the RouteGetter to the listening activity.

### Models
#### Route
The route model class holds all the information about a route generated by the server. It is constructed using the JSONObject received in the RouteGetter. Using this JSON, it will also created the objects needed in its respective fields. The points on the route are stored in an ArrayList, the same goes for the points of interest.

#### Point
This class holds the information necessary for drawing a point on the map. It is used to drawn the line of the route on the map. Because the LatLng class provided by Android is not storable in Firebase, it uses the MyLatLng class to store the location in Firebase. It is constructed by passing it a JSONObject which has a "lat" and "lng" key.

#### POI
This class extends the Point class and holds the information about a point of interest such as the name, description, picture, uri to the web resource. It is constructed with a JSONObject containing keys which are equivalent to the field names of the class. The generateHTML method will generate a basic page displaying the information about the POI for the InformationActivity.

#### MyLatLng
An implementation of a LatLng class which can be stored in Firebase.


## Development challenges
Most of the challenges came from interacting with Firebase and putting code in the wrong place. Also because Java only supports positional arguments I made some small errors with big impact when creating a route object. I wish I had known that the AsyncTask class cannot be serialized into Firebase as this would have spared me a day of angry debugging. I should have started using 3rd party libraries earlier which would have made development less error prone and made the code more beautifull straight away. It was much easier to use DavidWebb than the basic Java http code. Using Parcels would have made a lot of difference during development. I chose to cut some corners in the beginning which resulted in complacency with ugly and hard to maintain code for most of the three weeks. I was very happy when I discovered the Parcels library which made everything a lot cleaner.

Another challenge was not thinking about Java as though it was Python (my preferred language). After figuring out how interfaces worked it was getting easier and easier.
I adhered loosely to my design document, but after the big code cleanup moved the creation of Routes to the current activities the user was in at the moment. This moved logic out of the MapsActivity which should not have been in there. It's only use was to display a route, not generate it. This separation made the code more maintainable in my eyes.

In the end, the biggest challenge was getting Geofencing to work. It worked for one day, but the next day it stopped working without any changes to the code. I have spent 1 day and a half on getting it to work, asked 2 different assistents to help me but could not get it working properly. I decided to take my loss and get rid of it in my final version.

## Decisions
I decided to scrap the regenerate route functionality because it was something which had to do with the backend and would not be graded in the end. Instead I focussed more on adding login support and storing of routes. The application is only usable in portait mode, this decision is made because I see no added value to it being in landscape mode. The app is to be used when people are on the verge of leaving when they do not have two hands free to interact with their phone.
